/*
 *  Rapfi, a Gomoku/Renju playing engine supporting piskvork protocol.
 *  Copyright (C) 2022  Rapfi developers
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "../core/pos.h"
#include "../core/types.h"

#include <memory>
#include <vector>

namespace Tuning {

/// Result represents the outcome of a finished game (based on current side to move).
enum Result : uint8_t { RESULT_LOSS, RESULT_DRAW, RESULT_WIN };

/// DataEntry struct represents a raw training data entry that generated by running
/// a match between two engines. It contains the complete position (represented as
/// a sequence of move played by each side), move outputed by the current side to move,
/// board size, rule, game outcome and an optional policy target.
struct DataEntry
{
    std::vector<Pos>         position;   // move sequence that representing a position
    uint8_t                  boardsize;  // size of a square board
    Rule                     rule;
    Result                   result;  // game result: 0=loss, 1=draw, 2=win (side to move pov)
    Pos                      move;    // best move output by the engine
    std::unique_ptr<float[]> policy;  // optional policy target

    /// Get policy target according to pos. If no real policy target
    /// is available, all policy is concentrated on best move pos.
    float policyTarget(Pos pos) const
    {
        if (policy)
            return policy[pos.y() * boardsize + pos.x()];
        else
            return pos == move ? 1.0f : 0.0f;
    }
};

/// GameEntry struct represents a complete training game that generated
/// by running a match between two engines. Positions of each data entry can be
/// acquired from the move sequence outputed by two engines.
/// Note that policy target is not contained in GameEntry.
struct GameEntry
{
    std::vector<Pos> moves;
    int              numOpeningMoves;  // -1 for unknown
    uint8_t          boardsize;
    Rule             rule;
    Result           result;  // game result: 0=loss, 1=draw, 2=win (white pov)
};

}  // namespace Tuning
